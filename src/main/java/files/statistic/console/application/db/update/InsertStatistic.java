package files.statistic.console.application.db.update;

import files.statistic.console.application.statistic.TextFile;
import files.statistic.console.application.statistic.LineStatistic;

import java.sql.*;

/**
 * Created by mac on 17.06.17.
 */
public class InsertStatistic {

    private Connection conn;
    private TextFile file;

    public InsertStatistic(Connection conn, TextFile file) {
        this.conn = conn;
        this.file = file;
    }

    /**
     * In this method calling method to insert files statistic
     * and commit changes in the db
     */
    public void transactionUpdate() {
        /* Calling method which accomplish 3 sql-queries
         * to add statistic of a text file */
        insertFileStatistic();

        try {
            /* Important! This is commit of changing in the db.
             * This method will execute if only 3 sql queries accomplish successfully */
            conn.commit();
            /* After committing changes we can allow autocommitting */
            conn.setAutoCommit(true);
        } catch (SQLException e) {
            e.printStackTrace();
            System.err.println("Committing error!");
        }
    }

    /**
     * Goal of this method is inserting in one transaction file statistic by 3 sql queries
     * <p>
     * First sql inserts data of a text file and retrieves autogenerated key of one
     * Second sql inserts data of lines statistic and retrieves a list of autogenerated keys of ones
     * Third sql get autogenerated key of the text file and keys of lines statistic and inserts them,
     * it's need to provide one-to-many relationship between tables of text files and lines statistic
     */
    private void insertFileStatistic() {
        /* Insert file's data */
        UpdateProcessing updateProcessing[] = new UpdateProcessing[3];
        doUpdate("INSERT INTO File(name, dateStatComp) VALUES(?, ?)",
                (preparedStatement) -> {
                    preparedStatement.setString(1, file.getName());
                    preparedStatement.setTimestamp(2,
                            new Timestamp(file.getDateOfStatisticComputation().getTime()));
                    preparedStatement.executeUpdate();

                    ResultSet generatedKeys = preparedStatement.getGeneratedKeys();
                    generatedKeys.next();
                    file.setId(generatedKeys.getLong(1));
                });

        /* Insert lines statistic */
        doUpdate("INSERT INTO LineStatistic(longestWord, shortestWord, lineLength, averageWordLength) " +
                        "VALUES(?, ?, ?, ?)",
                (preparedStatement) -> {
                    for (LineStatistic line : file.getLines()) {
                        preparedStatement.setString(1, line.getLongestWord());
                        preparedStatement.setString(2, line.getShortestWord());
                        preparedStatement.setInt(3, line.getLineLength());
                        preparedStatement.setInt(4, line.getAvgWordLength());
                        preparedStatement.addBatch();
                    }
                    preparedStatement.executeBatch();

                    ResultSet generatedKeys = preparedStatement.getGeneratedKeys();
                    int i = 0;
                    while (generatedKeys.next()) {
                        file.getLines().get(i).setId(generatedKeys.getLong(1));
                        i++;
                    }
                });

        /* Insert a file's id and ids of lines statistic which associated with one */
        doUpdate("INSERT INTO File_LineStatistic(File_id, linesStatistic_id) VALUES(?, ?)",
                (preparedStatement) -> {
                    for (LineStatistic line : file.getLines()) {
                        preparedStatement.setLong(1, file.getId());
                        preparedStatement.setLong(2, line.getId());
                        preparedStatement.addBatch();
                    }
                    preparedStatement.executeBatch();
                });
        try {
            conn.commit();
        } catch (SQLException e) {
            e.printStackTrace();
            System.err.println("Committing error!");
        }
    }

    /**
     * This method create preparedStatement to comply pre-compiled sql queries
     * and for catching sql exceptions.
     * Method doUpdate rollbacks transaction if some exception happens.
     *
     * @param sql              sql-query
     * @param updateProcessing this variable of the functional interface,
     *                         it's need to put lambda expression to this method
     */
    private void doUpdate(String sql, UpdateProcessing updateProcessing) {
        try (PreparedStatement queryUpdate = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            conn.setAutoCommit(false);
            updateProcessing.insert(queryUpdate);
        } catch (SQLException e) {
            e.printStackTrace();
            if (conn != null) {
                try {
                    System.err.println("Transaction is being rolled back");
                    conn.rollback();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }
        }
    }
}
